/**
 * Based on the Babylon 5 Wars game system by Agents of Gaming TM & � Warner Bros.
 * Java design and implementation � Alex Packwood   
 */
package net.b5gamer.b5wars.unit.structural.system;

import java.util.List;

import net.b5gamer.b5wars.ui.logging.Logger;
import net.b5gamer.map.Arc;
import net.b5gamer.util.Properties;
import net.b5gamer.util.PropertyReader;

/**
 * !!--- work in progress ---!!
 * A Reactor provides power to weapons and other systems on a vessel 
 * 
 * 
 * reactor destroyed = ship/section (base) destroyed (even if multiple)
 * if shortage reactor shuts down, everything requiring power deactivated
 * announce deactivated
 * destroyed cannot be deactivated, loses power
 *  
 * 
 * @author Alex Packwood (aka PackyNZ)
 */
public class Reactor extends System implements PowerProvidingSystem {

	private static final long serialVersionUID = -2236182006919252651L;

	private final int     baseAvailablePower; // base amount of power generated by the reactor each turn
	private       int     availablePower;     // amount of power generated by the reactor each turn
	private       boolean activated  = true;  // whether the reactor is activated or deactivated
	private       boolean breached   = false; // whether the reactor was breached due to a critical hit
	private       boolean critical20 = false; // whether a natural 20 was rolled when checking for critical hits

	/**
	 * @param damageBoxes amount of damage the reactor can sustain before being destroyed
	 * @param armor       amount of armor protecting the reactor
	 * @param arc         arc for incoming fire, may be null
	 * @param name        name of the reactor, may be null
	 * @param properties  additional properties 
	 */
	public Reactor(final int damageBoxes, final int armor, final Arc arc, final String name,
			final Properties properties) {
		this(damageBoxes, armor, arc, name, PropertyReader.getInteger(properties, "availablePower"));
	}

	/**
	 * @param damageBoxes    amount of damage the reactor can sustain before being destroyed
	 * @param armor          amount of armor protecting the reactor
	 * @param arc            arc for incoming fire, may be null
	 * @param name           name of the reactor, may be null
	 * @param availablePower amount of power generated by the reactor each turn
	 */
	public Reactor(final int damageBoxes, final int armor, final Arc arc, final String name, 
			final int availablePower) {
		super(damageBoxes, armor, arc, name);
        
        this.baseAvailablePower = availablePower;
        this.availablePower     = availablePower;
	}
	
	@Override
	public Properties getInitProperties() {
		Properties properties = new Properties();
		properties.setProperty("availablePower", String.valueOf(getAvailablePower())); // TODO
		
		return properties;
	}
	
	public String getType() {
		return "Reactor";
	}
	
	public List<System> getEligibleSystems() {
		return getParent().getSystemsOfClass(PowerRequiringSystem.class);
	}
	
	/**
	 * the amount of power generated by the reactor each turn
	 * 
	 * @return the amount of power generated by the reactor each turn
	 */
	public int getExtraPower() {
		return availablePower;
	}
	
	/**
	 * the amount of power generated by the reactor each turn
	 * 
	 * @param extraPower the amount of power generated by the reactor each turn
	 */
	private void setExtraPower(final int availablePower) {
		this.availablePower = availablePower;
	}
	
	/**
	 * whether the reactor is activated or deactivated
	 * 
	 * @return whether the reactor is activated or deactivated
	 */
	public boolean isActivated() {
		return activated;
	}

	/**
	 * whether the reactor is activated or deactivated
	 * 
	 * @param activated whether the reactor is activated or deactivated
	 */
	public void setActivated(final boolean activated) {
		this.activated = activated;
	}

	/**
	 * whether the reactor was breached due to a critical hit
	 * 
	 * @return whether the reactor was breached due to a critical hit
	 */
	public boolean isBreached() {
		return breached;
	}

	/**
	 * whether the reactor was breached due to a critical hit
	 * 
	 * @param breached whether the reactor was breached due to a critical hit
	 */
	private void setBreached(final boolean breached) {
		this.breached = breached;
	}

	/**
	 * whether a natural 20 was rolled when checking for critical hits
	 * 
	 * @return whether a natural 20 was rolled when checking for critical hits
	 */
	public boolean isCritical20() {
		return critical20;
	}

	/**
	 * whether a natural 20 was rolled when checking for critical hits
	 * 
	 * @param critical20 whether a natural 20 was rolled when checking for critical hits
	 */
	private void setCritical20(final boolean critical20) {
		this.critical20 = critical20;
	}
	
	protected void resolveCriticalHit(final int roll) {
		Logger.info(roll + " rolled for " + getFullName() + "...");

		if (roll - getDamageSuffered() == 20) {
			setCritical20(true);
		}
		
		if (roll <= 10) {
			// no critical hit
			Logger.info("    - no critical hit");
		} else if (roll <= 14) {
			// minor power loss, -2 power
			setExtraPower(getExtraPower() - 2);
			Logger.info("    - minor power loss, -2 power");
		} else if (roll <= 18) {
			// moderate power loss, -4 power
			setExtraPower(getExtraPower() - 4);
			Logger.info("    - moderate power loss, -4 power");
		} else if (roll <= 26) {
			// major power loss, -8 power
			setExtraPower(getExtraPower() - 8);
			Logger.info("    - major power loss, -8 power");
		} else {
			// containment breach, -10 power
			setExtraPower(getExtraPower() - 10);	
			setBreached(true);
			Logger.info("    - containment breach, -10 power and " + getDamageSuffered() + "% of exploding per round while activated");
		}
	}		
	
	protected void adjustSystem() {
	}

	public int getOrder() {
		// TODO Auto-generated method stub
		return 0;
	}

	public int getBaseAvailablePower() {
		// TODO Auto-generated method stub
		return baseAvailablePower;
	}
	
	public int getAvailablePower() {
		// TODO Auto-generated method stub
		return getExtraPower();
	}

	public void setAvailablePower(int availablePower) {
		// TODO Auto-generated method stub
		
	}
	
	@Override
	public int getRecognitionOrder() {
		return 600;
	}
	
}
